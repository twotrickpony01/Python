import platform
from pathlib import Path
import datetime
import re
import subprocess
import browser_history

# Disable browser_history firing off notices of which browser is installed on a system
browser_history.utils.logger.setLevel('WARNING')

#### TODO ####

### GENERAL ###
# Make the tool accept arguments
# # Argparse

# Create an uncategorized files_modified / browser history function (and filter?)

# Windows/Linux environments need to be tested.

## END TODO ##


### Helpers ###
# These two converters are made useless by the browser_history module
def convert_datetime_to_epoch_time(datetime_object):
    """
    Converts a datetime object into epoch time
    """
    epoch_start = datetime.datetime(1601, 1, 1, tzinfo=datetime.timezone.utc)
    # Convert datetime_object to utc
    datetime_object_converted_to_utc = datetime_object.replace(tzinfo=datetime.timezone.utc)
    time_difference = datetime_object_converted_to_utc - epoch_start
    seconds_in_a_day = 24 * 60 * 60
    epoch_time = (time_difference.microseconds + (time_difference.seconds + time_difference.days * seconds_in_a_day) * 10**6)
    return epoch_time
   
def convert_from_epoch_time_to_datetime(epoch_time, date_format):
    """
    Converts epoch time into a datetime object.
    """
    epoch_start = datetime.datetime(1601, 1, 1, tzinfo=datetime.timezone.utc)
    date_time_object = (epoch_start + datetime.timedelta(microseconds=int(epoch_time))).strftime(date_format)
    return date_time_object

def get_dates_in_range(start_date, end_date, date_format):
    """
    Generates a dictionary of dates within a timerange. The keys represent the dates.
    """
    date_key_dict = {}
    for day in range(0, (end_date - start_date).days + 1):
        date = (start_date + datetime.timedelta(days=day)).strftime(date_format)
        date_key_dict[date] = []
    return date_key_dict

### Primary Functions ###
def identify_activities_by_name(activity):
    """
    This parses a file's name and maps it to an activity using regex.
    Keys of the regex_to_activity_mapping_dictionary are regex which are matched to values (strings) 
    that represent an undertaken action.
    If the file is not in the regex_to_activity_mapping_dictionary, it's returned as an Uncategorized activity. 
    """

    regex_to_activity_mapping_dictionary = {
        '.*burp.*': 'Evaluated <web_app> using BurpSuite.',
        '.*nmap.*':'Configured and ran Nmap scans.',
        '.*nessus.*':'Configured and ran Nessus scans.',
        '.*nikto.*': 'Configured and ran Nikto scans.'
    }
    
    for identifying_regex in regex_to_activity_mapping_dictionary:
        if re.search(identifying_regex, activity):
            return regex_to_activity_mapping_dictionary[identifying_regex]
        else:
            return f"Uncategorized activity: {activity}"

def get_all_files_by_mod_time(directory_object, activities_by_date_dict, date_format, file_types_to_check_tuple = None):
    """"
    This finds all files that have been modified between two dates. 
    It returns a dictionary of files that have been modified, by date (primary key).
    Optional file_types_to_check_tuple argument specifies which extensions to look for.
    directory parameter can be a list or a Path object 
    """
    # Get all of the files using pathlib and an rglob regex
    # Apparently calling stat().st_mtime on each file can be very slow, so just 
    # grab all files and filter them first so we can reduce the load

    # List comprehensions get very confusing to read in these scenarios. I'm going to go with
    # readability and understandability over the speed increases offered by list comprehensions
    # This is some ugly-ass code.
    if isinstance(directory_object, list):
        files = []
        if file_types_to_check_tuple:
            for directory_path in directory_object:
                for path in directory_path.rglob("*"):
                    if path.is_file() and path._str.endswith(file_types_to_check_tuple):
                        files.append(path)
        else:
            for directory_path in directory_object:
                for path in directory_path.rglob("*"):
                    if path.is_file():
                        files.append(path)


    if isinstance(directory_object, type(Path())):
        if file_types_to_check_tuple:
            files = [path for path in directory_object.rglob("*") if path.is_file() and path._str.endswith(file_types_to_check_tuple)]
        else:
            files = [path for path in directory_object.rglob("*") if path.is_file()]

    # Check dates of files and add them to the files_by_date_dict (date:[list_of_file_names])
    for file in files:
        file_mod_date = datetime.datetime.fromtimestamp(file.stat().st_mtime).strftime(date_format)
        if file_mod_date in activities_by_date_dict:
            activities_by_date_dict[file_mod_date].append(file._str) #._str attribute is string-ified Path
        else:
            activities_by_date_dict[file_mod_date] = [file._str]
    
    return activities_by_date_dict

def get_browser_history(activities_by_date_dict, date_format):
    """"
    Returns all webpage titles within the beginning and ending dates
    These are organized into the date dictionary
    """
    histories = browser_history.get_history().histories
    for search in histories:
        date = search[0].strftime(date_format)
        if date in activities_by_date_dict:
            activities_by_date_dict[date].append(search[2])
    return activities_by_date_dict

def timeline_file_generator(activity_by_date, timeline_file):
    """
    Takes the generated activities by date dictionary and outputs a file with the activity-strings organized
        by date.  
    """
    with open(timeline_file, 'a+', encoding="utf-8") as timeline:
        for date in activity_by_date:
            timeline.write(f'{date}\n')
            for activity in activity_by_date[date]:
                if activity:
                    timeline.write(f'{identify_activities_by_name(activity)}\n')
            timeline.write('\n')

def create_scheduled_task(operating_system):
    """
    Creates a Windows Scheduled Task or a Linux Cronjob to run the script daily, so re-occuring modifications of a file
    indicate repeated activity over multiple days.
    We may want to change this in the future to allow for specific times / dates / days of the week
    """
    
    if operating_system == 'Windows':
        windows_schedule_task = f'schtasks /Create /sc weekly /D MON,TUE,WED,THU,FRI /st 17:30 /TR "python3 {__file__}" \
            /TN "Timeline_generator.py script @twotrickpony01 on GitHub"'
        subprocess.call(windows_schedule_task)
    
    elif operating_system == 'Linux':
        
        # This could cause an issue if the user is not root
        import os
        if os.geteuid() != 0:
            print('You need to execute this script as root to create a cron job.')
            exit()
        
        # python-crontab
        from crontab import CronTab
        cron = CronTab(user='root', tabfile='/etc/crontab')
        job = cron.new(command=f'python3 {__file__}')
        job.minute.on(30)
        job.hour.on(17) # 5PM
        job.day.on(1, 2, 3, 4, 5) # Mon. - Fri.
        # job.comment('Timeline_generator.py script; twotrickpony01 on GitHub')
        cron.write()

def main():
    
    # Configuration Details
    user_directory = str(Path.home())
    operating_system = platform.system()
    date_format = "%m/%d/%Y"
    file_types_to_check_tuple = ()

    # The directory (and its sub-directories) that will be searched for modified files.
    search_directory = Path(f"{user_directory}/")

    # Location of the output file
    output_file_name = 'timeline_file.txt'
    timeline_file = f"{user_directory}/{output_file_name}"

    # The activities_by_date_dict holds the information on all of the activities that have happened 
    start_date = datetime.datetime(2023, 12, 1)
    end_date = datetime.datetime(2023, 3, 18)
    activities_by_date_dict = get_dates_in_range(start_date, end_date, date_format)

    # Modules 
    files_by_date = get_all_files_by_mod_time(search_directory, activities_by_date_dict, date_format, file_types_to_check_tuple)
    browser_history_module = get_browser_history(activities_by_date_dict, date_format)

    timeline_file_generator(activities_by_date_dict, timeline_file)
    
    #create_scheduled_task(operating_system)


def tests():
    date_format = "%m/%d/%Y"
    start_date = datetime.datetime(2024, 3, 20)
    end_date = datetime.datetime(2024, 3, 22)
    file_types_to_check_tuple = ('md', 'txt', '.py')
    search_directory = [Path("/home/kali/Downloads"), Path("/opt/nginxpwner")]
    activities_by_date_dict = get_dates_in_range(start_date, end_date, date_format)
    files_by_date = get_all_files_by_mod_time(search_directory, activities_by_date_dict, date_format, file_types_to_check_tuple)
    print(files_by_date['03/20/2024'])

    


if __name__ == "__main__":
    # main()
    tests()