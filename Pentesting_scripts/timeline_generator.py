import platform
from pathlib import Path
import datetime
import re
import subprocess
import browser_history

# Disable browser_history firing off notices of which browser is installed on a system
browser_history.utils.logger.setLevel('WARNING')

## TODO ##
## GENERAL ##
# Add docstrings

# Make the tool accept arguments
# # Argparse

# Create an uncategorized files_modified / browser history function (and filter?)

# Consider some way to identify targets of actions. 
#   Would be difficult as it would require that we dig into the files.

# Should create a setup script that adds this to a Windows / Linux scheduled task. Can use platform library for this
# # Opted to use the cron module for Linux systems; might be worth doing it another way. 

# Windows/Linux environments need to be tested.

# Get Python History
# Get Powershell History

## LINUX ##
# Get history from the hist file and parse it

## END LINUX ## 


## END TODO ##


### Helpers ###
def convert_datetime_to_epoch_time(datetime_object):
    """
    Converts a datetime object into epoch time
    """
    epoch_start = datetime.datetime(1601, 1, 1, tzinfo=datetime.timezone.utc)
    # Convert datetime_object to utc
    datetime_object_converted_to_utc = datetime_object.replace(tzinfo=datetime.timezone.utc)
    time_difference = datetime_object_converted_to_utc - epoch_start
    seconds_in_a_day = 24 * 60 * 60
    time = (time_difference.microseconds + (time_difference.seconds + time_difference.days * seconds_in_a_day) * 10**6)
    return time

    
def convert_from_epoch_time_to_datetime(epoch_time, date_format):
    """
    Converts epoch time into a datetime object.
    """
    epoch_start = datetime.datetime(1601, 1, 1, tzinfo=datetime.timezone.utc)
    time = (epoch_start + datetime.timedelta(microseconds=int(epoch_time))).strftime(date_format)
    return time


def get_dates_in_range(start_date, end_date, date_format):
    """
    Generates a dictionary of dates within a timerange. The keys represent the dates.
    """
    # I think that there's an easier way to handle this in so many functions, but I'm not sure how
    # Pre-populate the dictionary with dates
    date_key_dict = {}
    for day in range(0, (end_date - start_date).days + 1):
        date = (start_date + datetime.timedelta(days=day)).strftime(date_format)
        date_key_dict[date] = []
    return date_key_dict

### Primary Functions ###
def identify_activities_by_name(file_name):
    """
    This parses a file's name and maps it to an activity using regex.
    Keys of the regex_to_activity_mapping_dictionary are regex which are matched to values (strings) 
    that represent an undertaken action.
    If the file is not in the regex_to_activity_mapping_dictionary, it's returned as an Uncategorized activity. 
    """
    # Use regex to map a string to an activity.
    # Can be file names, page titles, etc.
    # Decided to use regex rather than .endswith() so I have more flexibility 
    regex_to_activity_mapping_dictionary = {
        '.*burp.*': 'Evaluated <web_app> using BurpSuite.',
        '.*nmap.*':'Configured and ran Nmap scans.',
        '.*nessus.*':'Configured and ran Nessus scans.',
        '.*nikto.*': 'Configured and ran Nikto scans.'
    }
    
    for key in regex_to_activity_mapping_dictionary:
        if re.search(key, file_name):
            return regex_to_activity_mapping_dictionary[key]
        else:
            return f"Uncategorized activity: {file_name}"

def get_all_files_by_mod_time(directory, activities_by_date_dict, date_format, file_types_to_check_tuple = None):
    """"
    This finds all files that have been modified between two dates. 
    It returns a dictionary of files that have been modified, by date (primary key).
    Optional file_types_to_check_tuple argument specifies which extensions to look for. 
    """
    # Get all of the files using pathlib and an rglob regex
    # Apparently calling stat().st_mtime on each file can be very slow, so just 
    # grab all files and filter them first so we can reduce the load
    if file_types_to_check_tuple:
        files = [path for path in directory.rglob("*") if path.is_file() and path._str.endswith(file_types_to_check_tuple)]
    else:
        files = [path for path in directory.rglob("*") if path.is_file()]

    # Check dates of files and add them to the files_by_date_dict (date:[list_of_file_names])
    for file in files:
        file_mod_date = datetime.datetime.fromtimestamp(file.stat().st_mtime).strftime(date_format)
        if file_mod_date in activities_by_date_dict:
            activities_by_date_dict[file_mod_date].append(file._str) #._str attribute is string-ified Path
        else:
            activities_by_date_dict[file_mod_date] = [file._str]
    
    return activities_by_date_dict

def get_browser_history(activities_by_date_dict, date_format):
    histories = browser_history.get_history().histories
    for search in histories:
        date = search[0].strftime(date_format)
        if date in activities_by_date_dict:
            activities_by_date_dict[date].append(search[2])
    return activities_by_date_dict

def timeline_file_generator(activity_by_date, timeline_file):
    """
    Takes the generated activities by date dictionary and outputs a file with the activity-strings organized
        by date.  
    """
    # TO DO
    # Needs to check for an already existing timeline file and ammend it for an already existing date.
    # Make a seperate timeline_file_generator for html

    with open(timeline_file, 'w+', encoding="utf-8") as timeline:
        for date in activity_by_date:
            timeline.write(f'{date}\n')
            for activity in activity_by_date[date]:
                if activity:
                    timeline.write(f'{identify_activities_by_name(activity)}\n')
            timeline.write('\n')

def create_scheduled_task(operating_system):
    """
    Creates a Windows Scheduled Task or a Linux Cronjob to run the script daily, so re-occuring modifications of a file
    indicate repeated activity over multiple days. 
    """
    
    if operating_system == 'Windows':
        subprocess.call(f'schtasks /Create /sc weekly /D MON,TUE,WED,THU,FRI /st 17:30 /TR "python3 {__file__}" /TN "Timeline_generator.py script @twotrickpony01 on GitHub"')
    elif operating_system == 'Linux':
        # This could cause an issue if the user is not root
        # python-crontab
        from crontab import CronTab
        cron = CronTab(user='root', tabfile='/etc/crontab')
        job = cron.new(command=f'python3 {__file__}')
        job.minute.on(30)
        job.hour.on(17) # 5PM
        job.day.on(1, 2, 3, 4, 5) # Mon. - Fri.
        # job.comment('Timeline_generator.py script; twotrickpony01 on GitHub')
        cron.write()

def main():
    # TO DO 
    
    # Configuration Details
    user_directory = str(Path.home())
    operating_system = platform.system()
    date_format = "%m/%d/%Y"
    file_types_to_check_list = []

    # The directory (and its sub-directories) that will be searched for modified files.
    search_directory = Path(f"{user_directory}/")

    # Location of the output file
    output_file_name = 'timeline_file.txt'
    timeline_file = f"{user_directory}/{output_file_name}"

    # The activities_by_date_dict holds the information on all of the activities that have happened 
    start_date = datetime.datetime(2023, 12, 1)
    end_date = datetime.datetime(2023, 3, 18)
    activities_by_date_dict = get_dates_in_range(start_date, end_date, date_format)

    # Modules 
    files_by_date = get_all_files_by_mod_time(search_directory, activities_by_date_dict, date_format, ('txt', 'burp')) 
    browser_history_module = get_browser_history(activities_by_date_dict, date_format)

    timeline_file_generator(activities_by_date_dict, timeline_file)
    create_scheduled_task(operating_system)


def tests():
    a = dir(browser_history.utils.logger.setLevel('WARNING'))
    print(a)


if __name__ == "__main__":
    main()
    # tests()