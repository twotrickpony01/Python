import platform
from pathlib import Path
import datetime
import re
import sqlite3
import subprocess

## TODO ##
# Integrate get_dates_in_range function and consider making it a passed object throughout the tool

# Make the tool accept arguments
# # Argparse

# Create an uncategorized files_modified / browser history function (and filter?)
# # There's probably a better place to put this information than into the existing file

# Consider some way to identify targets of actions. 
#   Would be difficult as it would require that we dig into the files.

# Should create a setup script that adds this to a Windows / Linux scheduled task. Can use platform library for this
# # Opted to use the cron module for Linux systems; might be worth doing it another way. 

# Windows/Linux environments need to be tested.

## END TODO ##


### Helpers ###
def convert_to_epoch_time(datetime_object):
    epoch_start = datetime.datetime(1601, 1, 1, tzinfo=datetime.timezone.utc)
    # Convert datetime_object to utc
    datetime_object_converted_to_utc = datetime_object.replace(tzinfo=datetime.timezone.utc)
    time_difference = datetime_object_converted_to_utc - epoch_start
    seconds_in_a_day = 24 * 60 * 60
    time = (time_difference.microseconds + (time_difference.seconds + time_difference.days * seconds_in_a_day) * 10**6)
    return time

    
def convert_from_epoch_time(epoch_time, date_format):
    epoch_start = datetime.datetime(1601, 1, 1, tzinfo=datetime.timezone.utc)
    time = (epoch_start + datetime.timedelta(microseconds=int(epoch_time))).strftime(date_format)
    return time


def get_dates_in_range(start_date, end_date, date_format):
    # I think that there's an easier way to handle this in so many functions, but I'm not sure how
    # Pre-populate the dictionary with dates
    date_key_dict = {}
    for day in range(0, (end_date - start_date).days + 1):
        date = (start_date + datetime.timedelta(days=day)).strftime(date_format)
        date_key_dict[date] = []
    return date_key_dict

### Primary Functions ###
def identify_activities_by_name(file_name):
    # Use regex to map a string to an activity.
    # Can be file names, page titles, etc.
    # Decided to use regex rather than .endswith() so I have more flexibility 
    regex_to_activity_mapping_dictionary = {
        '.*burp.*': 'Evaluated <web_app> using BurpSuite.',
        '.*nmap.*':'Configured and ran Nmap scans.',
        '.*nessus.*':'Configured and ran Nessus scans.',
        '.*nikto.*': 'Configured and ran Nikto scans.'
    }
    
    for key in regex_to_activity_mapping_dictionary:
        if re.search(key, file_name):
            return regex_to_activity_mapping_dictionary[key]
        else:
            return f"Uncategorized activity: {file_name}"

def get_all_files_by_mod_time(directory, start_date, end_date, date_format, file_types_to_check_tuple = None):
    # Check the modify / creation time of files on the OS and return them
    # file_types_to_check_tuple acts as a filter for which files to search for
    files_by_date_dict = {}
    
    # Pre-populate the dictionary with dates
    for day in range(0, (end_date - start_date).days + 1):
        date = (start_date + datetime.timedelta(days=day)).strftime(date_format)
        files_by_date_dict[date] = []

    # Get all of the files using pathlib and an rglob regex
    # Apparently calling stat().st_mtime on each file can be very slow, so just 
    # grab all files and filter them first so we can reduce the load
    if file_types_to_check_tuple:
        files = [path for path in directory.rglob("*") if path.is_file() and path._str.endswith(file_types_to_check_tuple)]
    else:
        files = [path for path in directory.rglob("*") if path.is_file()]

    # Check dates of files and add them to the files_by_date_dict (date:[list_of_file_names])
    for file in files:
        file_mod_date = datetime.datetime.fromtimestamp(file.stat().st_mtime)
        if start_date <= file_mod_date <= end_date:
            file_mod_date_formatted = file_mod_date.strftime(date_format)
            if files_by_date_dict[file_mod_date_formatted]:
                files_by_date_dict[file_mod_date_formatted].append(file._str) #._str attribute is string-ified Path
            else:
                files_by_date_dict[file_mod_date_formatted] = [file._str]
    
    return files_by_date_dict

def get_chrome_history(chrome_history_file_location, start_date, end_date, date_format):
    # TO DO 
    # Add in option to close / reopen Chrome
    # Integrate get_dates_in_range function
    # # files_by_date_dict = get_dates_in_range(start_date, end_date, date_format)
    files_by_date_dict = {}
    # Pre-populate the dictionary with dates
    for day in range(0, (end_date - start_date).days + 1):
        date = (start_date + datetime.timedelta(days=day)).strftime(date_format)
        files_by_date_dict[date] = [] 

    # Should add logic to ask users if we should be closing out chrome here or check for a flag to see if this 
    # should be done whether or not users are on and watching the script's execution.

    sqlite_chrome_connection = sqlite3.connect(chrome_history_file_location)

    epoch_start_date = convert_to_epoch_time(start_date)
    epoch_end_date = convert_to_epoch_time(end_date)

    sql_statement = f"""
                SELECT title,last_visit_time FROM urls 
                WHERE last_visit_time > {epoch_start_date}
                AND last_visit_time < {epoch_end_date} 
                ORDER BY last_visit_time DESC;""" 

    try:   
        pages_visited = sqlite_chrome_connection.execute(sql_statement).fetchall()
    except sqlite3.OperationalError:
        print('Cannot read Chrome history while Chrome is open. Please close Chrome and run this script again.')
        return files_by_date_dict
    
    for page in pages_visited:
        date = convert_from_epoch_time(page[1], date_format)
        if files_by_date_dict[date]:
                files_by_date_dict[date].append(page[0])
        else:
            files_by_date_dict[date] = [page[0]]

    sqlite_chrome_connection.close()

    # Re-open Chrome here.

    return files_by_date_dict    

def consolidate_dates_between_modules(list_of_dictionaries, start_date, end_date, date_format):
    # TO DO 
    # Integrate get_dates_in_range here ( or pass the dictionary / object for it )
    # # consolidated_dictionaries = get_dates_in_range(start_date, end_date, date_format)
    consolidated_dictionaries = {}
    # Pre-populate the dictionary with dates
    for day in range(0, (end_date - start_date).days + 1):
        date = (start_date + datetime.timedelta(days=day)).strftime(date_format)
        consolidated_dictionaries[date] = []

    for dictionary in list_of_dictionaries:
        tmp_dictionary = consolidated_dictionaries
        for date in dictionary:
            # Remove duplicates using list(dict.fromkeys()) trick
            old_and_new_values = list(dict.fromkeys(consolidated_dictionaries[date] + dictionary[date]))
            tmp_dictionary[date] = old_and_new_values
        consolidated_dictionaries = tmp_dictionary

    return consolidated_dictionaries

def timeline_file_generator(activity_by_date, timeline_file, output_mode = None):
    # TO DO
    # Needs to check for an already existing timeline file and ammend it for an already existing date.

    with open(timeline_file, 'w+', encoding="utf-8") as timeline:
        for date in activity_by_date:
            timeline.write(f'{date}\n')
            for activity in activity_by_date[date]:
                if activity:
                    if output_mode == 'html':
                        timeline.write(f'<li>{identify_activities_by_name(activity)}</li>\n')
                    else:
                         timeline.write(f'{identify_activities_by_name(activity)}\n')
            timeline.write('\n')
        return

def create_scheduled_task(operating_system):
    if operating_system == 'Windows':
        subprocess.call(f'schtasks /Create /sc weekly /D MON,TUE,WED,THU,FRI /st 17:30 /TR "python3 {__file__}" /TN "Timeline_generator.py script @twotrickpony01 on GitHub"')
    elif operating_system == 'Linux':
        # This could cause an issue if the user is not root
        from crontab import CronTab
        cron = CronTab(user='root')
        job = cron.new(command=f'python3 {__file__}')
        job.minute.on(30)
        job.hour.on(17) # 5PM
        job.day.on(1, 2, 3, 4, 5) # Mon. - Fri.
        job.comment('Timeline_generator.py script @twotrickpony01 on GitHub')
        cron.write()
    else:
        print(f"Could not identify Operating System: {operating_system}")

def main():
    # TO DO 
    # Integrate create_scheduled_task
    # Integrate dynamic location of chrome history file
    
    # Configuration Details
    user_directory = str(Path.home())
    operating_system = platform.system()
    if operating_system == 'Windows':
        chrome_history_file = Path(f"{user_directory}/AppData/Local/Google/Chrome/User Data/Default/History")
    elif operating_system == 'Linux':
        # This needs to be added
        # Will need to make something for FireFox if users are moving that way
        chrome_history_file = Path("")
    
    date_format = "%m/%d/%Y"
    file_types_to_check_list = []

    # directory variable is the directory (and its sub-directories) that will be searched for files.
    directory = Path(f"{user_directory}/Downloads/")

    # Location of the output file
    output_file_name = 'timeline_file.txt'
    timeline_file = f"{user_directory}/Desktop/{output_file_name}"

    start_date = datetime.datetime(2023, 12, 1)
    end_date = datetime.datetime(2023, 12, 12)
    # Create dictionary object with date_ranges here

    # Modules 
    files_by_date = get_all_files_by_mod_time(directory, start_date, end_date, date_format, ('txt', 'burp')) 
    chrome_history = get_chrome_history(chrome_history_file, start_date, end_date, date_format)

    # Consolidate
    # Will this be necessary if we pass the dictionary of items by their date?
    consolidated_dictionaries = consolidate_dates_between_modules([files_by_date, chrome_history], start_date, end_date, date_format)
    print(consolidated_dictionaries)
    timeline_file_generator(consolidated_dictionaries, timeline_file)
    # create_scheduled_task(operating_system)

if __name__ == "__main__":
    main()